package amalgamation

import (
	"crypto/sha256"
	"fmt"
	"github.com/samber/lo"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/themakers/pastor/lib/helm"
	"github.com/themakers/pastor/lib/http"
	"github.com/themakers/pastor/lib/yml"
)

const FileName = "amalgamation.gen.yaml"

type Amalgamation struct {
	manifests []string
}

func New() Amalgamation {
	return Amalgamation{}
}

type AddHelmChartOptions struct {
	Repo         string
	ChartName    string
	ChartVersion string
	ChartURL     string
	ReleaseName  string
	Namespace    string
	Values       map[string]any
}

func (a *Amalgamation) AddHelmChart(opt AddHelmChartOptions) {
	a.AddManifest(helm.RenderChartFromRemoteRepo(
		opt.Repo,
		opt.ChartName,
		opt.ChartVersion,
		opt.ReleaseName,
		opt.Namespace,
		opt.Values,
	))
}

func (a *Amalgamation) AddRemoteManifest(path string) {
	if strings.HasPrefix(path, "http://") || strings.HasPrefix(path, "https://") {
		a.AddManifest(string(http.Get(path)))
	} else {
		if content, err := os.ReadFile(path); err != nil {
			panic(err)
		} else {
			a.AddManifest(string(content))
		}
	}
}

func (a *Amalgamation) AddManifest(text string) {
	for _, doc := range yml.SplitIntoDocuments(text) {
		a.manifests = append(a.manifests, doc)
	}
}

func (a *Amalgamation) Render() string {
	type Manifest struct {
		Text   string
		Header yml.ManifestHeader
	}
	var manifests []Manifest

	for _, manifest := range a.manifests {
		var header = yml.ParseHeader(manifest)
		manifest = yml.Label(manifest, "app.kubernetes.io/managed-by", "pastor")
		manifest = yml.Label(manifest, "pastor/managed", "true")
		manifest = yml.Label(manifest, "pastor/apply-stage", fmt.Sprint(header.Group()))
		manifests = append(manifests, Manifest{
			Text:   manifest,
			Header: header,
		})
	}

	slices.SortStableFunc(manifests, func(m1, m2 Manifest) int {
		if g1, g2 := m1.Header.Group(), m2.Header.Group(); g1 < g2 {
			return -1
		} else if g1 > g2 {
			return 1
		} else {
			if h1, h2 := m1.Header.Hash(), m2.Header.Hash(); h1 < h2 {
				return -1
			} else if h1 > h2 {
				return 1
			} else {
				panic("duplicate manifest")
			}
		}
	})

	var buf strings.Builder
	for _, manifest := range manifests {
		buf.WriteString("\n---\n")
		buf.WriteString(manifest.Text)
	}
	var amalgamationText = fmt.Sprintf("%s\n", strings.Trim(buf.String(), "\r\n\t "))

	return fmt.Sprintf(
		"# generated by pastor; do not edit\n# v0.0.0\n# hash: %x\n\n%s",
		sha256.Sum256([]byte(amalgamationText)),
		amalgamationText,
	)
}

func (a *Amalgamation) Dump(dir string) {
	if err := os.WriteFile(filepath.Join(dir, FileName), []byte(a.Render()), 0644); err != nil {
		panic(err)
	}
}

func listTypes(text string) []string {
	return lo.Uniq(lo.Map(lo.Filter(
		regexp.MustCompile(
			`(?m)^\s*apiVersion:\s*(\S+)\s*^\s*kind:\s*(\S+)`,
		).FindAllStringSubmatch(text, -1),
		func(match []string, _ int) bool {
			return len(match) == 3
		}),
		func(match []string, _ int) string {
			return fmt.Sprintf("%s/%s", match[1], match[2])
		}))
}
